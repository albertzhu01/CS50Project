# Project Design: Technical Documentation for Productivity Hub

## Google Sign-In API Troubles

At the beginning of this project, we planned to incorporate Google Calendar api into our website in order to develop a side-by-side todo list and calendar functionality. In order to do this, we registered our product “Productivity Hub” with Google APIs at console.developers.google.com. This process involved authorizing domains enabling scopes (email, profile, openid, and calendar), both of which we completed via OAuth consent screen. Once registering, we received a client ID (1003445858249-jjm8gp2o9c4egc9c40o7715441rb4aq2.apps.googleusercontent.com) and API key (AIzaSyAm7s-uomhJ0lWtBgLIHRcC7_2qNIG-vaE) in order to activate both Google Sign-In and Google Calendar. However, after going through these steps we ran into some problems. Notably, in order to gain access to user’s Google Calendars (ability to view, edit, and delete), Google requires that we submit our application for verification -- a process that involves creating a terms of service, privacy policy, and submitting an official product for review. Because this process was beyond the scope of CS50’s project, we decided to instead provide a Google Calendar for the user that contains pre-inputted values and allow them to interact with the calendar and use it for the process of making todos, planning their schedule, etc. although they would not be able to add their own events. However, we still hoped to include Google Oauth Sign-In in our website so that users could smoothly connect to our web app using their preexisting account. In order to learn how to integrate Google Sign-In into our web app, we watched numerous tutorials, loaded the Google Platform library, rendered a Google sign in button, and developed the necessary code for managing the users’ profile information as received from Google.
Here is a sampling of the code we initially included within the backend to operate sign-in.
function onSignIn(googleUser) {
  var profile = googleUser.getBasicProfile();
  console.log('ID: ' + profile.getId());
console.log('Name: ' + profile.getName());
  console.log('Image URL: ' + profile.getImageUrl());
  console.log('Email: ' + profile.getEmail());
}
<a href="#" onclick="signOut();">Sign out</a>
<script>
  function signOut() {
    var auth2 = gapi.auth2.getAuthInstance();
    auth2.signOut().then(function () {
      console.log('User signed out.');
    });
  }
</script>
Much of Thanksgiving break and the days leading up to the hackathon were dedicated to implementing the sign-in functionality (as well as baseline html templates). However, we faced a persistent error when attempting to use this feature to sign in with Google that stated that the domain was not authorized. In fact, we had authorized the domain (cs50.xyz) in the Google OAuth consent screen, but were not able to authorize the complete domain on account of it not being a “top private domain.” After conducting research and consulting others for advice about this error, we decided to move our website to heroku in order to get a secure domain and a server that was disconnected from the CS50 IDE.

## Heroku Troubles

In Heroku, we made an account and connected the various members of our team and created a new project that linked to a repository on Github (to which we transferred all files from CS50). Using gunicorn dyno formation and heroku postgres. We got an API Key (3d8b1589-2f0c-4861-b2a0-2dc99aca8bd2) and attempted numerous times to deploy our project to Heroku using the step-by-step instructions laid out by Brain Yu. However, after spending collectively 10+ hours trying to deploy our app to Github, and getting Heroku help from TFs (Moshe and Kareem) at the CS50 Hackathon, we ultimately decided to abandon our vision of deploying via Heroku and enabling Google Sign-In. At this point, we had downloaded numerous CLIs and attempted countless builds. Ultimately, we were successful in building and deploying our app on Github, although this led to another challenge with buildpacks. The python and js buildpacks that were installed were not recognized correctly by Heroku, so despite the successful deployment -- 5445c0fc -- we still were unable to view our app. We were able to meet with our TF Jenny mid-hackathon and adjust our plans moving forward. We shifted our project back onto the IDE and decided to take more of a finance-route by coding the features ourselves as opposed to APIs and using session[“user_id”] rather than implementing Google Sign-In.

## JavaScript Troubles

Back in the IDE, we began coding our flagship features. One of these included our todo list. In order to implement this, we created a todo.html file containing a stylesheet for an aesthetic user interface, html that features the todo list, and javascript that enables an interactive design. This preliminary todo list enabled users to press enter to add a new todo, check a box to cross it out, and click an X mark in order to delete it. This javascript syntax was new to us and required lots of research, but it resulted in a seamless, accessible design that operated without reloading the page or redirecting the user. However, we soon ran into the next barrier: the todo entries made by the users were processed by javascript, which did not communicate with the backend. As a result, these todos would not be saved in a database for the user. To overcome this problem, we extensively researched forums about passing variables from javascript to flask, posted on Ed (to which we received an answer about Fetch), and read documentation about Fetch and Ajax. We tested code from online and watched tutorials, and ultimately, by combining jquery and ajax commands, we were able to use methods such as $.post() to post data to application.py and then insert it into a SQL table without refreshing the page. However, we couldn’t figure out how to pass the values from the database back into the html files so that the todos that the user created would still exist on the page even when the user leaves the page.  After spending a significant amount of time trying to implement this feature, we once again decided to make a design change, shifting our program to a form-based web app rather than a javascript-driven one.

## Registering a User

When registering a user, we asked for 4 inputs: name, username, password, and password confirmation. We ask for a name and username because we would like each user's username to be unique; however,
two users can have the same name because when they log into their homepage, they will be greeted by their name. When a user creates an account, these 4 inputs are entered into a table called "users".
In addition, there are two other fields in this table that we later added in order to store information from the study group feature (groupid) and the user’s profile settings (avatar). The user's groupid will initially be NULL until the user joins a study group, and their avatar will be set to the Harvard Crest by default.
Users can later change their avatar in the Settings Page.

## Creating, Completing, Editing, and Deleting Todo's

### Creating a Todo

When a user wants to create a todo, they can do so through the Todo Page. The user is taken to todo.html, where they can input all of the entries. Once the user inputs everything and submits the info,
todo.html will post to the "/todo" route in application.py. The "/todo" route inputs all of the user's information into a table called "todos". The data that will be inputted when the user creates a todo
are the name of the todo, the priority, the ranking, the category, the addtime, the user's id, and "false" for the complete field. The ranking field is simply the priority field but in integer form, and
the priority is also changed to an rgb color. The rgb color is then passed into list.html to set the background of the todos based on priority. The users table also contains other field, including
endtime, reflect, comments, and timespect. These fields are NULL when the todo is created and are only populated with values once the user completes the todo.

### Completing a Todo

The user can mark a todo as completed through the list.html page. A dropdown is used so that the user can only complete the todos that they have created. Once they user selects a todo and submits it, the post method in list.html is called with the select tag named “complete” so that in application.py, the “complete” branch of the “/list” route is executed. The ID of the todo that was marked as complete is passed to application.py, and this way, we can mark the todo as complete even if the same user has todos with the same name. Afterwards, the route renders completed.html, which contains the form that the user will fill out with their reflections, comments, etc. This info is then passed into the “/completed” route in application.py using the “POST” method, where complete field for the todo is set to “true” and the rest of the fields (e.g. reflection) are updated as well with the user’s inputs. Lastly, the user is redirected to “history.html” where they can see their completed todos. These completed todos are displayed by selecting the user’s todos from the todos table that have “true” in their complete field.

### Editing a Todo

The user can edit a todo through list.html. Like completing a todo, a dropdown of the user’s incomplete todos (i.e. in the todos table, complete = “false”) will allow the user to edit a todo they already have. Upon selecting a todo to edit, the “POST” method for the “/list” route in application.py will be called with the select tag named “edit”. This way, application.py will know which branch of the “/list” route to execute to edit a todo. The route will get the id and name of the todo to be edited and also the categories of the todos that the user has created. These will all be passed into edit.html, which will display a form to the user for them to edit either the priority of their todo, the category, or both. Once the user competed the fields, edit.html will call the “/edit” route in application.py via the “POST” method. The “/edit” route will get all of the information inputted by the user, including the id of the todo that the user has edited, and it will update that todo of the todos table with the name category and/or priority. The addtime of the todo will also be updated with the current timestamp. Once again, we designed our program to pass the ID of the todo from edit.html to application.py so that we can edit the correct todo, even if the same user has multiple todos with the same name.

### Deleting a Todo

Lastly, the user can delete a todo through list.html. Again, there is a dropdown for the user to select their incomplete todos. Upon selecting a todo, “list.html” will call the “POST” method for the “/list” route with the select tag named “delete”. The ID of the todo will be passed to the “delete” branch of the “/list” route, and in that branch, the todo will be deleted from the todos table. Then, there are lines of code that re-display the table in “list.html” because the table also needs to be displayed if the “POST” method is called (which occurs when the user deletes a todo). Lastly, the route renders “list.html” so that the user is taken back to their list of incomplete todos.

## The History Page

The History Page (history.html) was implemented in a similar way as “list.html”. In list.html, the tables only showed todos that were incomplete (which were determined by using a SQL query to select the todos whose complete fields were “false”), whereas in history.html, the todos had complete = “true”. In addition, the user is allowed to delete a completed todo permanently from their history page. Deleting a todo in history.html functions in exactly the same way as deleting a todo in list.html because we decided that it was more efficient to have the same functionality for both methods of deleting a todo.

## Making, Joining, Changing, and Viewing Groups
The user can make, join, or change groups within the “Study Group” tab on our website. On this tab, the user can see three buttons that they can click that will take them to a corresponding html page: Make Group, Join Group, and View Group. When the user clicks on one of these buttons, the page will be redirected to another page with a “window.location.href” function. A user can make a group in “/groupmake” where they will see a form that they will have to fill out to make their group. The page is similar to register and includes three text boxes for a group name, a pin, and a pin confirmation. The user must fill in all text boxes and both the pin and pin confirmation must match for the group to be made. The name of the group must also be unique and cannot be taken. This is checked by searching the SQL database titled “studygroup” for a group with the inputted name. Once all requirements are met, the information is posted to “/groupmake” in application.py. The post method will allow the website to store this information into “studygroup.” A row with the new group’s name, pin, and an automatically generated id will be inserted into the table. Once the group has been made, the creator of the group will now have a “groupid” of the newly created group in their respective column in the users database. To join a group, the user will find a page for joining a group by clicking on the “Join Group” button. Here they will find a page similar to “/login” where they will enter a group name and the group’s pin. Once they enter this information, it will be posted to “/groupjoin” which will check if the group name is an existing group and the entered pin corresponds to the given group name. Again, once the requirements are met, the user becomes part of the group by the same SQL queries as in “/groupmake”. To change groups, the user can simply go to the same page they used to join a group. Here, they will enter the name and pin of the new group that they would like to join. By the same process as joining their first group, the “users” table will be updated for the user and the user’s groupid will now be the new group’s id. Clicking on the “View Group” button on “studygroup.html” will redirect users to “groups.html”. In this page, they will be able to view a table that includes information from all of the users in the group that they are currently in. This contents of this table are extracted by several SQL queries. First, the page executes a query that gets the name of the user’s group. After this information is stored, another SQL query is done to find the id’s of all the users who have this groupid in their row in the users database. Along with this SQL query, we also find the number of todos completed and sum of “timespent” by the users in the group. All of this information is sorted into different lists for each element of the table. These lists are then passed into groups.html where we utilize for-loops to get each of the data. Some problems we encountered when making this table were getting the users and todos/timespent to correspond with each other. We resolved this by creating different lists in which each place of the element is related to the same user. In addition, in this groups page, the user can interact with other users via a chatroom that we embedded from Dead Simple Chat. This functionality allows users to communicate with each other about studying.

## Homepage

The homepage is the first page the user is directed to after logging in. We made this page greet the user through a combination of SQL queries and jinja code. The welcome text was made by configuring a class of “app-title” which is used throughout the website for a consistent, professional look. In addition, the user is prompted to set a focus for the day, which, after doing so, will be displayed back to the user in lightblue italic font. Another key feature in the homepage is the presence of an avatar in the upper right corner that is communicated via the settings route and stored in the user’s database. The avatar is stored by default as the harvard crest in the database upon registration, although it can be changed in settings to a tree or david malan icon. This feature allows the user to personalize their homepage. Additionally, using css margins and formatting, we managed to keep the avatar in the correct position in the upper-right corner of the page at all times, regardless of how the user resizes their browser.

## Creating a Focus

To create a focus for each user, we created a new database called focus that had the user_id and focus as its two fields. We decided to create a new database as opposed to adding a focus field in the todos database because the user’s focus is only used and displayed in the user’s homepage. On the user’s homepage, the user can click on a lightbulb icon to create a focus. This calls the post method in the “/home” route in application.py and renders focus.html. In focus.html, the user can input their daily focus, and once they submit their focus, they will post to the “/focus” route in application.py. The route will then update the focus database of the user. When the user logs out, their focus will be reset. We decided to design the focus so that it resets because it allows the user to create a new focus when they log back in later.

## Integrating Music

We integrated music from Spotify by using the Spotify Embed Code. The embeds were formatted using CSS and JavaScript so that when the user first goes to the music page, they only see a Spotify button. When they click on that button, buttons for different genres of music will appear, and once one of those buttons clicked, a playlist of that genre will appear. We decided to design the music page in this manner because it would allow the user to toggle between different genres of music depending on their mood.

## Calendar

Following our process of trying to implement Google Calendar (see above), we decided to instead embed a Google Calendar that contains pre-inputted information that could be helpful to the user in completing their tasks. This includes a calendar with holidays as well as a calendar with the important dates in the Harvard schedule such as reading period, winter break, etc. It allows users to navigate forward and back through the months or weeks, depending on whether the user is in week or month mode. The user can also view an agenda with a consolidated list of the important dates coming up. On the bottom-right corner of the calendar, the user also has a button that allows them to import the information of the calendar into their own Google Calendar.

## Tips

For our tips page, we included a title and a dropdown with different things that users may need advice on. When a specific dropdown option is selected, a tip will appear below the dropdown box. This is accomplished with a few lines of JavaScript; depending on the value of the option selected by the user, the JavaScript code will alter the html content to display text relating to the selected option.

## Settings

The settings page, which can be reached either via the nav bar or by clicking on the avatar in the upper-right corner, contains two forms that enable the user to personalize their experience. The first form provides the option for snow in the homepage, which can be updated by clicking either the “snow in home” or “no snow in home” button. Once update settings is clicked, the user is redirected to the homepage, where they will see snow falling from the page and receive a success message that “settings were updated”. We were able to make this snow feature possible through a jinja template in home.html {% if snow == ‘true’ %} and passing in the value of this variable from the flask routes. In addition, we incorporated snowflake icons with javascript from online to finalize the effect. The second option for the user is the ability to change their avatar from the default Harvard Crest to either a David Malan icon or tree icon. When the user updates this setting by selecting a dropdown option and clicking submit, they will be redirected to home where they will be flashed a success message and be able to view the selected avatar in the top right of their page. This avatar is stored in the database users, such that their settings will remain intact even when logging in and out of the website.


## Study Break

While working on this website, we figured that study breaks are essential when studying. Therefore, we decided to include a study break page consisting of a game that the user can play to take a break from working on their todos. For this, we found a simple Javascript game on Google and implemented this code in “studybreak.html.” We initially tried to extend the layout from layout.html, however we found that this did not work because of the way that the game was programmed. Because of this, we had to make studybreak.html its own html page that did not simply extend layout.html. In order to achieve this, we took code from other html pages and adapted them to meet the layout specifications of the dinosaur game from Google.


## CSS

For the aesthetics aspect of our website, we implemented many different classes into “styles.css”. We implemented a background and altered its opacity to get the ideal background for users. We also ensured that adjusting the size of the browser would not greatly affect the elements of the page or the background (the background gets smaller and larger as the page size is adjusted). Each row in the todo-list table was styled to be a slightly transparent color corresponding to the priority of the todo (red for high, yellow for med, blue for low). When trying to position different elements into our page, we ran into many problems getting them exactly where we intended. Hence, we were forced to make adjustments to the style of almost every unique element in our html pages. Ultimately, however, we were able to get our website exactly the way we wanted it to look. We also included icons from flaticon.com from the different tabs on our page. We could not simply import the icon from the page, because the black background of the navbar would not show the black icon. Therefore, we had to also edit each icon in miniPaint.com and change the color of them. In addition, we used a similar process to edit the avatars, using http://crop-circle.imageonline.co/ in order to make circular/transparent icons. We also implemented a favicon and tab title using similar design as that used in finance.

Ultimately, our webpage seeks to meet a crucial absence in the market of productivity and todo apps: the ability to have many features all in one place. Using our website, users can write todos, organize them by attributes such as their category and priority, among others, reflect on their todos, view and interact with a calendar, listen to music, join a study group, view a history of their todos and stats about their study group, get tips, and take study breaks. Rather than having dozens of tabs open in a browser, users can use our productivity hub to meet all of their study needs in one place.
